Для списка свободных m будем использовать связный список, т.к. добавление и удаление элементов будет происходить довольно часто

Для хранения списков предпочтений manPref\[m,i] и womanPref\[w,i] будут использоваться двумерные списки

Необходимо, чтобы каждая из следующих операций выполнялась за постоянное время O(1):
	1). Найти свободного m
	2). Для m - найти женщину с наивысшей оценкой, которой он еще не делал предложение
	3). Для w - проверить, находится ли w в состоянии помолвки, и если находится, найти её текущего
	4). Для w и двух m и m' определить (также за постоянное время), кто из них является более предпочтительным для w

##### Алгоритм
- Множество свободных мужчин собрать в связный список. Выбор свободного m - первый элемент списка. Вставка свободного m' - в начало списка
- Для хранения следующей w, которой m будет делать предложение используем массив *next\[m]*, который инициализируется нулями (список предпочтений отсортирован в убывающем порядке). m делает предложение `w = manPref[m,next[m]]`, после этого `next[m]++` независимо от ответа
- Для хранения текущих женихов w будет массив `current[w]`, который инициализируется `-1`
- Чтобы сравнить m и m' за постоянное время, создадим двумерный массив `ranking[w,m]`, который создается для каждой w за линейное время n => общие затраты n (количество женщин) \* n = n^2
